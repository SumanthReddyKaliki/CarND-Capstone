#+LATEX_CLASS: article
#+LATEX_CLASS_OPTIONS:
#+LATEX_HEADER:
#+LATEX_HEADER_EXTRA:
#+DESCRIPTION:
#+KEYWORDS:
#+SUBTITLE:
#+LATEX_COMPILER: pdflatex
#+DATE: \today

#+OPTIONS: ^:nil

#+TITLE: Design and Construction of tl_detector (traffic light detector)


* Source Code

** Top level

 Here we construct the source code from top to bottom.

 #+NAME:tl_dectector
 #+BEGIN_SRC python :noweb tangle :tangle ./ros/src/tl_detector/tl_detector.py
   #!/usr/bin/env python
   <<imports>>
   <<waypoint_to_light_f>>

   STATE_COUNT_THRESHOLD = 3

   class TLDetector(WaypointTracker):
       def __init__(self):
           WaypointTracker.__init__(self)

           rospy.init_node('tl_detector')
           <<attributes-initialization>>
           <<subscribers>>
           config_string = rospy.get_param("/traffic_light_config")
           self.config = yaml.load(config_string)
           # self.previous_traffic_light_position = 0
           # self.number_traffic_lights_passed = 0

           self.upcoming_red_light_pub = rospy.Publisher('/traffic_waypoint', Int32, queue_size=1)

           <<traffic_image_processing_initialization>>
           <<traffic_light_initialization>>
           rospy.spin()
       <<base_waypoints_cb>>
       <<current_pose_cb>>
       <<traffic_array_cb>>
       <<image_color_cb>>
       <<get_light_state>>
       <<process_traffic_lights>>

   if __name__ == '__main__':
       try:
           TLDetector()
       except rospy.ROSInterruptException:
           rospy.logerr('Could not start traffic node.')
 #+END_SRC

** imports

#+NAME:imports
#+BEGIN_SRC python :noweb tangle :tangle
  import rospy
  from std_msgs.msg import Int32
  from geometry_msgs.msg import PoseStamped, Pose
  from styx_msgs.msg import TrafficLightArray, TrafficLight
  from styx_msgs.msg import Lane
  from sensor_msgs.msg import Image
  from cv_bridge import CvBridge

  from light_classification.tl_classifier import TLClassifier
  from waypoint_lib.waypoint_tracker import WaypointTracker

  import tf as tf_ros
  import math
  import cv2
  import yaml
#+END_SRC

** attributes-initialization

self.lights is from TrafficLightArray.lights, the position and state of traffic lights.

#+NAME:attributes-initialization
#+BEGIN_SRC python :noweb tangle :tangle
  self.pose = None
  self.waypoints = None
  self.camera_image = None
  self.lights = []
#+END_SRC

** subscribers

#+NAME:subscribers
#+BEGIN_SRC python :noweb tangle :tangle
  self.current_pose_sub1 = rospy.Subscriber('/current_pose', PoseStamped, self.current_pose_cb)
  self.base_waypoints_sub = rospy.Subscriber('/base_waypoints', Lane, self.base_waypoints_cb)

  '''
  /vehicle/traffic_lights provides you with the location of the traffic light in 3D map space and
  helps you acquire an accurate ground truth data source for the traffic light
  classifier by sending the current color state of all traffic lights in the
  simulator. When testing on the vehicle, the color state will not be available. You'll need to
  rely on the position of the light and the camera image to predict it.
  '''
  sub3 = rospy.Subscriber('/vehicle/traffic_lights', TrafficLightArray, self.traffic_array_cb)
  sub6 = rospy.Subscriber('/image_color', Image, self.image_color_cb)

#+END_SRC

** traffic_light_initialization

#+NAME:traffic_light_initialization
#+BEGIN_SRC python :noweb tangle :tangle
  self.state = TrafficLight.UNKNOWN
  self.last_state = TrafficLight.UNKNOWN
  self.last_wp = -1
  self.state_count = 0

#+END_SRC

** traffic_image_processing_initialization

#+NAME:traffic_image_processing_initialization
#+BEGIN_SRC python :noweb tangle :tangle
  self.bridge = CvBridge()
  self.light_classifier = TLClassifier()
  self.listener = tf_ros.TransformListener()

#+END_SRC

** base_waypoints_cb

   So far, it only need to digest and process the base_points and store them. This has been implemented in the
   super-class.

#+NAME:base_waypoints_cb
#+BEGIN_SRC python :noweb tangle :tangle
  def base_waypoints_cb(self, msg):
      WaypointTracker.base_waypoints_process(self, msg)
      <<traffic_lights_to_waypoints>>
#+END_SRC

** traffic_lights_to_waypoints

   Identify waypoint index with traffic lights once.

   For each traffic light, find the closest waypoint, record the index of the waypoint.
   Then build a map from the index of a waypoint in front of the car to the waypoint for a traffic light ahead of the waypoint ahead of the car.
   The index of the traffic light should be eqqual or greater than the index of the waypoint ahead of the car.

#+NAME:traffic_lights_to_waypoints
#+BEGIN_SRC python :noweb tangle :tangle
  # assumption that a traffic light can only have one waypoint close to it.
  # or one waypoint can have at most one traffic light near it.

  # implementation:
  # given a list of coordinates of traffic lights
  # List of positions that correspond to the line to stop in front of for a given intersection
  stop_line_positions = self.config['stop_line_positions']
  light_cursor = 0
  base_waypoint_search_cursor = 0

  dl = lambda a, b: math.sqrt((a.x-b[0])**2 + (a.y-b[1])**2)
  lights_to_waypoints = []

  for light_cursor in range(len(stop_line_positions)):
      # take, l, the first of the remaining traffic lights coordinates list, self.stop_line_positions
      if base_waypoint_search_cursor < self.base_waypoints_num:
          dist_shortest = dl(self.base_waypoints[base_waypoint_search_cursor].pose.pose.position,
                              stop_line_positions[light_cursor])
          light_waypoint_index = base_waypoint_search_cursor

          # for l to find the closest waypoint in the remaining base_waypoints, w
          for i in range(base_waypoint_search_cursor+1, self.base_waypoints_num):
              dist = dl(self.base_waypoints[i].pose.pose.position,
                        stop_line_positions[light_cursor])
              if dist < dist_shortest:
                  dist_shortest = dist
                  light_waypoint_index = i
              # end of if dist < d_shortest
          # end of for i in range(base_waypoint_search_cursor+1, self.base_waypoints_num)
          # record the mapping from l to w
          lights_to_waypoints.append(light_waypoint_index)
          # remove l from the list of traffic lights, and w from the base_points
          base_waypoint_search_cursor = light_waypoint_index + 1
      else:
          lights_to_waypoints.append(None)
      # end of if base_waypoint_search_cursor < self.base_waypoints_num
  # end of for light_cursor in range(len(self.stop_line_positions))
  # until there is no more traffic light, or no more waypoint

  # construct the map, self.waypoint_to_light, the map from waypoint index to the index of the
  # traffic light in terms of the closest waypoint index
  self.waypoint_to_light = waypoint_to_light_f(lights_to_waypoints, self.base_waypoints_num)
  # rospy.loginfo('test using self.waypoint_to_light[237]: %r' % self.waypoint_to_light[237])
#+END_SRC

** traffic_light_waypoint

   A function from an index of a waypoint (ahead of the car) to the waypoint index of the traffic light.

   This should be the replacement for self.find_closest_traffic_light

#+NAME:traffic_light_waypoint
#+BEGIN_SRC python :noweb tangle :tangle
  # construct a function or map from waypoint index in front of a car to the index of the waypoirt for traffic light
  # I know how to do it with map, but how to do it with function?

  def traffic_light_waypoint(self, waypoint_index):
      if self.waypoint_to_light is None:
          # construct the map
          self.waypoint_to_light = {}
          waypoint_start = 0
          for light_index in range(len(self.lights_to_waypoints)):
              for waypoint_index in range(waypoint_start, self.base_waypoints_num):
                  if waypoint_index < self.lights_to_waypoints[light_index]:
                      self.waypoint_to_light[waypoint_index] = self.lights_to_waypoints[light_index]
                  # end of if waypoint_index <= self.lights_to_waypoints[light_index]
                  waypoint_start = waypoint_index
              # end of for i in range(self.base_waypoints_num)
          # end of for light_index in range(len(self.lights_to_waypoints))
      # end of if self.waypoint_to_light is None
      return self.waypoint_to_light[waypoint_index]
#+END_SRC

** waypoint_to_light_f

   The function to construct the map between the index of a waypoint and the index of the waypoint nearest to the traffic light.

#+NAME:waypoint_to_light_f
#+BEGIN_SRC python :noweb tangle :tangle
  def waypoint_to_light_f(lights_to_waypoints, base_waypoints_num):
      # implementation
      waypoint_to_light = {}
      light_next = 0

      for waypoint_index in range(base_waypoints_num):
          for light_index in range(light_next, len(lights_to_waypoints)):
              if waypoint_index < lights_to_waypoints[light_index]:
                  waypoint_to_light[waypoint_index] = (light_index, lights_to_waypoints[light_index])
                  break
              elif lights_to_waypoints[-1] <= waypoint_index:
                  waypoint_to_light[waypoint_index] = (None, None)
                  break
              # end of if waypoint_index <= lights_to_waypoints[light_index]
              light_next = light_index
          # end of for light_index in range(len(lights_to_waypoints))
      # end of for i in range(base_waypoints_num)
      return waypoint_to_light

  # test data:
  lights_to_waypoints = [1, 3, 7, 8, 10, 15]
  base_waypoints_num = 17

  y = waypoint_to_light_f(lights_to_waypoints, base_waypoints_num)
  # expected outcome:
  x = (y == {0: (0, 1), 1: (1, 3), 2: (1, 3), 3: (2, 7), 4: (2, 7), 5: (2, 7), 6: (2, 7), 7: (3, 8), 8: (4, 10), 8: (4, 10),
                       9: (4, 10), 10: (5, 15), 11: (5, 15), 12: (5, 15), 13: (5, 15), 14: (5, 15), 15: (None, None), 16: (None, None)})
#+END_SRC

** current_pose_cb

   - Determine the location of the car by locating the nearest waypoint in front of the car
   -
#+NAME:current_pose_cb
#+BEGIN_SRC python :noweb tangle :tangle
  def current_pose_cb(self, msg):
      self.pose = msg
#+END_SRC

** traffic_array_cb

#+NAME:traffic_array_cb
#+BEGIN_SRC python :noweb tangle :tangle
  def traffic_array_cb(self, msg):
      self.lights = msg.lights

#+END_SRC

** image_color_cb

   Delegate the processing of the image, recognition to self.process_traffic_lights

   Publish stable recognition outcome in terms of /traffic_waypoint (index)
- Frequency of /image_color::
It's about 10 Hz by observing through ==rostopic hz /image_color==

MAJOR CHANGE of the protocol between waypoints_updater and tl_detector ::
when the traffic light color is not red, report the negative of the waypoint index instead of just report -1, to take advantage of the computation of the waypoint index of the traffic light, saving waypoint_updater from computing it.

#+NAME:image_color_cb
#+BEGIN_SRC python :noweb tangle :tangle
  def image_color_cb(self, msg):
      """Identifies red lights in the incoming camera image and publishes the index
              of the waypoint closest to the red light's stop line to /traffic_waypoint

          Args:
              msg (Image): image from car-mounted camera

      """
      self.has_image = True
      self.camera_image = msg
      light_wp, state = self.process_traffic_lights()
      if light_wp and state:
          '''
          Publish upcoming red lights at camera frequency.
          Each predicted state has to occur `STATE_COUNT_THRESHOLD` number
          of times till we start using it. Otherwise the previous stable state is
          used.
          '''
          if self.state != state:
              self.state_count = 0
              self.state = state
          elif self.state_count >= STATE_COUNT_THRESHOLD:
              self.last_state = self.state
              light_wp = light_wp if state == TrafficLight.RED else -light_wp
              self.last_wp = light_wp
              self.upcoming_red_light_pub.publish(Int32(light_wp))
          else:
              self.upcoming_red_light_pub.publish(Int32(self.last_wp))
          # end of if self.state != state
          self.state_count += 1
      # end of if light_wp and state
#+END_SRC

** process_traffic_lights

#+NAME:process_traffic_lights
#+BEGIN_SRC python :noweb tangle :tangle
    def process_traffic_lights(self):
        """Finds closest visible traffic light, if one exists, and determines its
            location and color

        Returns:
            int: index of waypoint closes to the upcoming stop line for a traffic light (-1 if none exists)
            int: ID of traffic light color (specified in styx_msgs/TrafficLight)

        """
        light = None

        # List of positions that correspond to the line to stop in front of for a given intersection
        # self.stop_line_positions = self.config['stop_line_positions']

        if (self.pose):
            car_position = self.get_closest_waypoint(self.pose.pose)
            if car_position:
                #TODO find the closest visible traffic light (if one exists)
                # the index of the waypoint of the traffic light
                light_index, light_wp = self.waypoint_to_light[car_position]
                # self.find_closest_traffic_light(car_position)
                rospy.loginfo('light_index: %r; light waypoint: %r' % (light_index, light_wp))
                if light_index:
                    state = self.get_light_state(light_index)
                    return light_wp, state
                # end of if light_index
            # end of if car_position:
        # end of if (self.pose)
        return None, None
#+END_SRC

** find-closest-traffic-light

Based on the current car_position, and the previous_traffic_light_position, find the next traffic_light_position
#+NAME:find-closest-traffic-light
#+BEGIN_SRC python :noweb tangle :tangle
  def find_closest_traffic_light(self, car_position_index):
      # remaining_traffic_ligths = len(self.stop_line_positions)-self.number_traffic_lights_passed
      if self.number_traffic_lights_passed < len(self.stop_line_positions)-1:
          dl = lambda a, b: math.sqrt((a.x-b[0])**2 + (a.y-b[1])**2)
          # find the closest traffic light to the car's position
          traffic_light_index = self.previous_traffic_light_position
          d_shortest = dl(self.base_waypoints[car_position_index].pose.pose.position,
                          self.stop_line_positions[self.previous_traffic_light_position])

          for i in range(self.previous_traffic_light_position+1, len(self.stop_line_positions)):
              d = dl(self.base_waypoints[car_position_index].pose.pose.position,
                     self.stop_line_positions[i])
              if d < d_shortest:  # found the closest
                  d_shortest = d
                  traffic_light_index = i
              # end of if d < d_shortest
          # end of for i in range(self.previous_traffic_light_position+1, len(self.stop_line_positions))
          self.previous_traffic_light_position = traffic_light_index
          # self.number_traffic_lights_passed += 1

          # find the closest base_waypoint to the found traffic light.
          nearest_waypoint_for_the_light = car_position_index
          d_shortest = dl(self.base_waypoints[car_position_index].pose.pose.position,
                          self.stop_line_positions[traffic_light_index])

          for j in range(car_position_index + 1, len(self.base_waypoints)):
              d = dl(self.base_waypoints[j].pose.pose.position,
                     self.stop_line_positions[traffic_light_index])
              if d < d_shortest:
                  d_shortest = d
                  nearest_waypoint_for_the_light = j
              # end of if d < d_shortest
          # end of for j in range(car_position_index, len(self.base_waypoints)-car_position_index)
          return traffic_light_index, nearest_waypoint_for_the_light
      else:
          return None, None
      # end of self.number_traffic_lights_passed < len(self.stop_line_positions)-1
#+END_SRC

** get_closest_waypoint

Use the implementation of the super-class, WaypointTracker.

#+NAME:get_closest_waypoint
#+BEGIN_SRC python :noweb tangle :tangle
  # def get_closest_waypoint(self, pose):
  #     """Identifies the closest path waypoint to the given position
  #         https://en.wikipedia.org/wiki/Closest_pair_of_points_problem
  #     Args:
  #         pose (Pose): position to match a waypoint to

  #     Returns:
  #         int: index of the closest waypoint in self.waypoints

  #     """
  #     #TODO implement
  #     return 0

#+END_SRC

** get_light_state

I assume/design the light parameter is the index of the nearest traffic light in the list of traffic lights.
#+NAME:get_light_state
#+BEGIN_SRC python :noweb tangle :tangle
  def get_light_state(self, light_index):
      """Determines the current color of the traffic light

      Args:
          light_index (TrafficLight): light to classify

      Returns:
          int: ID of traffic light color (specified in styx_msgs/TrafficLight)

      """
      FAKED_LIGHT = True
      if FAKED_LIGHT:
          rospy.loginfo('light_index: %d; state: %d; the light is RED: %r' % (
              light_index, self.lights[light_index].state,
              self.lights[light_index].state == TrafficLight.RED))
          return self.lights[light_index].state
      # end of if FAKED_LIGHT

      if(not self.has_image):
          self.prev_light_loc = None
          return None

      cv_image = self.bridge.imgmsg_to_cv2(self.camera_image, "bgr8")

      #Get classification
      return self.light_classifier.get_classification(cv_image)

#+END_SRC

** Current problems

As of 11/17, 22:15, the light index calculated seems not right. The car has already passed the first traffic light, it still
reported light_index: 0 (the first), while the waypoint index keeps changing.

The logic is not right. The waypoint index should remain the same.

