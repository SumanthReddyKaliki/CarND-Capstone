#+LATEX_CLASS: article
#+LATEX_CLASS_OPTIONS:
#+LATEX_HEADER:
#+LATEX_HEADER_EXTRA:
#+DESCRIPTION:
#+KEYWORDS:
#+SUBTITLE:
#+LATEX_COMPILER: pdflatex
#+DATE: \today

#+TITLE: Waypoint Traceback

This is a super class to capture the common functionality of waypoint updater and tl_dectector for
waypoint related functionality.

* WaypointTracker

A super-class for both WaypointTracker and TLDetector

** Top level
#+NAME:waypoint-tracker
#+BEGIN_SRC python :noweb tangle :tangle ./ros/src/waypoint_lib/src/waypoint_lib/waypoint_tracker.py
  import copy
  import math
  import rospy

  import yaml

  <<get_yaw>>
  <<to_local_coordinates>>

  <<waypoint_to_light_f>>

  class WaypointTracker(object):
      def __init__(self):
          self.base_waypoints = None
          self.base_waypoints_num = None
          self.pose = None
          self.lights_to_waypoints = []  # The list of the waypoint index of the traffic lights

          self.last_closest_front_waypoint_index = 0
          config_string = rospy.get_param("/traffic_light_config")
          self.config = yaml.load(config_string)

          # this is a super_class, so it will not start loop nor spin()
          # it expects the subclass will implement the appropriate

      <<base_waypoints_process>>
      <<current_pose_cb>>
      <<get_closest_waypoint>>
      <<distance>>
      <<distance_two_indices>>
#+END_SRC

** base_waypoints_process

    - Subscribe to /base_waypoint has been done in the __init__
    - implement the callback to store it and declare its availability.
    - compute the distance from the start of the base_waypoints to a base_waypoint stored into an array self.dist_to_here_from_start::
    the i_th element is the distance from the 0_th waypoint to the (i)_th waypoint.
    - also record the shortest distance to neighbor
    - 11/13 ::
               add back the computation of self.shortest_dist_to_next_waypoint
    in order to optimize the computation of the waypoint index of the traffic lights.

#+NAME:base_waypoints_process
#+BEGIN_SRC python :noweb tangle :tangle
  def base_waypoints_process(self, msg):
      # DONE: Implement
      waypoints = msg.waypoints
      if self.base_waypoints is None:
          # unsubscribe to the waypoint messages, no longer needed
          self.base_waypoints_sub.unregister()
          self.subscriber_waypoints = None

          self.base_waypoints_num = len(waypoints)

          # process the waypoints here
          self.dist_to_here_from_start = []
          self.base_waypoints = []
          dist = 0
          dist_so_far = 0
          self.shortest_dist_to_next_waypoint = 0
          for i in range(self.base_waypoints_num):
              dist_so_far += dist
              self.dist_to_here_from_start.append(dist_so_far)

              # do a deep copy of the data, to keep the data from lose
              # just to be safe, simply do shallow copy seems still working
              # by self.base_waypoints = waypoints
              self.base_waypoints.append(copy.deepcopy(waypoints[i]))
              # distance to the next waypoint
              if (i < self.base_waypoints_num-1):
                  dist = (
                      self.distance_two_indices(waypoints,  # the (i+1)_th element has not been copied yet
                                                i, (i+1) % self.base_waypoints_num))
              # end of if (i < self.base_waypoints_num-1)
              if (dist < self.shortest_dist_to_next_waypoint):
                  self.shortest_dist_to_next_waypoint = dist
              # end of if (dist < self.shortest_dist_to_next_waypoint)
          # end of for i in range(self.base_waypoints_num - 1)
      # end of if self.base_waypoints is None
      # Construct the map, self.waypoint_to_light from a waypoint index to the traffic light
      # in terms of waypoint index

      <<traffic_lights_to_waypoints>>

#+END_SRC
** traffic_lights_to_waypoints

   Identify waypoint index with traffic lights once.

   For each traffic light, find the closest waypoint, record the index of that waypoint.
   Then build a map from the index of a waypoint in front of the car to the waypoint for a traffic light ahead of the waypoint ahead of the car.
   The index of the traffic light should be equal or greater than the index of the waypoint ahead of the car.
tl_detector/

#+NAME:traffic_lights_to_waypoints
#+BEGIN_SRC python :noweb tangle :tangle
  # assumption that a traffic light can only have one waypoint close to it.
  # or one waypoint can have at most one traffic light near it.

  # implementation:
  # given a list of coordinates of traffic lights
  # List of positions that correspond to the line to stop in front of for a given intersection
  stop_line_positions = self.config['stop_line_positions']
  light_cursor = 0
  base_waypoint_search_cursor = 0

  dl = lambda a, b: math.sqrt((a.x-b[0])**2 + (a.y-b[1])**2)

  # The list of the waypoint index of the traffic lights
  self.lights_to_waypoints = []

  for light_cursor in range(len(stop_line_positions)):
      # take, l, the first of the remaining traffic lights coordinates list, self.stop_line_positions
      if base_waypoint_search_cursor < self.base_waypoints_num:
          dist_shortest = dl(self.base_waypoints[base_waypoint_search_cursor].pose.pose.position,
                              stop_line_positions[light_cursor])
          light_waypoint_index = base_waypoint_search_cursor

          # for l to find the closest waypoint in the remaining base_waypoints, w
          for i in range(base_waypoint_search_cursor+1, self.base_waypoints_num):
              dist = dl(self.base_waypoints[i].pose.pose.position,
                        stop_line_positions[light_cursor])
              if dist < dist_shortest:
                  dist_shortest = dist
                  light_waypoint_index = i
              # end of if dist < d_shortest
          # end of for i in range(base_waypoint_search_cursor+1, self.base_waypoints_num)
          # record the mapping from l to w
          self.lights_to_waypoints.append(light_waypoint_index)
          # remove l from the list of traffic lights, and w from the base_points
          base_waypoint_search_cursor = light_waypoint_index + 1
      else:
          # there is extra traffic lights after having found the traffic light for the last waypoint.
          self.lights_to_waypoints.append(None)
      # end of if base_waypoint_search_cursor < self.base_waypoints_num
  # end of for light_cursor in range(len(self.stop_line_positions))
  # until there is no more traffic light, or no more waypoint
  rospy.loginfo('Waypoints for traffic lights: %r' % repr(self.lights_to_waypoints))

  # construct the map, self.waypoint_to_light, the map from waypoint index to the index of the
  # traffic light in terms of the closest waypoint index
  self.waypoint_to_light = waypoint_to_light_f(self.lights_to_waypoints, self.base_waypoints_num)
  # rospy.loginfo('test using self.waypoint_to_light[237]: %r' % self.waypoint_to_light[237])
#+END_SRC

** waypoint_to_light_f

   The function to construct the map between the index of a waypoint and the index of the waypoint nearest to the traffic light.

#+NAME:waypoint_to_light_f
#+BEGIN_SRC python :noweb tangle :tangle
  def waypoint_to_light_f(lights_to_waypoints, base_waypoints_num):
      # implementation
      waypoint_to_light = {}
      light_next = 0

      for waypoint_index in range(base_waypoints_num):
          for light_index in range(light_next, len(lights_to_waypoints)):
              waypoint_index_of_light = lights_to_waypoints[light_index]
              if waypoint_index < waypoint_index_of_light:
                  waypoint_to_light[waypoint_index] = (light_index, waypoint_index_of_light)
                  break
              elif lights_to_waypoints[-1] <= waypoint_index:
                  waypoint_to_light[waypoint_index] = (None, None)
                  break
              # end of if waypoint_index <= waypoint_index_of_light
              light_next = light_index
          # end of for light_index in range(len(lights_to_waypoints))
      # end of for i in range(base_waypoints_num)
      return waypoint_to_light

  # test data:
  lights_to_waypoints = [1, 3, 7, 8, 10, 15]
  base_waypoints_num = 17

  y = waypoint_to_light_f(lights_to_waypoints, base_waypoints_num)
  # expected outcome:
  x = (y == {0: (0, 1), 1: (1, 3), 2: (1, 3), 3: (2, 7), 4: (2, 7), 5: (2, 7), 6: (2, 7), 7: (3, 8), 8: (4, 10), 8: (4, 10),
                       9: (4, 10), 10: (5, 15), 11: (5, 15), 12: (5, 15), 13: (5, 15), 14: (5, 15), 15: (None, None), 16: (None, None)})
#+END_SRC


** current_pose_cb
    - Subscribe to /current_pose is done in __init__

    - 11/6 ::
    change pose_cb only update the self.pose message, moving the function of generating waypoints ahead to self.loop.
    This is to make the call back more time responsive to improve overall system predictability.
    Only accept message when Waypoint_Updater is ready to process, otherwise reject /current_pose update to avoid delay.

#+NAME:current_pose_cb
#+BEGIN_SRC python :noweb tangle :tangle
  def current_pose_cb(self, msg):
      # WORKING: Implement
      #
      if self.pose is None:       # ready to process message
          self.pose = msg
      # end of if self.pose is None
      # otherwise, the current message is being processed, rejected the coming message and expect to receive more updated next one.
#+END_SRC

** get_closest_waypoint
#+NAME:get_closest_waypoint_hector
#+BEGIN_SRC python :noweb tangle :tangle
      def get_closest_waypoint(self, pose):

          closest_len = 100000
          closest_index = 0

          waypoints = self.base_waypoints

          for i in range(len(waypoints)):
              waypoint = waypoints[i].pose.pose.position
              d = self.dist_hector(pose.position, waypoint)
              if d < closest_len:
                  closest_len = d
                  closest_index = i
              # end of if d < closest_len:
          # end of for i in range(len(waypoints))
          return closest_index
#+END_SRC

Need to have dist_hector to make it working.

It only tries to find the closest in distance, regardless of orientation.

#+NAME:get_closest_waypoint
#+BEGIN_SRC python :noweb tangle :tangle
  def get_closest_waypoint(self, pose):
      if self.base_waypoints_num is not None:
          current_pose = pose.position
          current_orientation = pose.orientation
          yaw = get_yaw(current_orientation)

          # Compute the waypoints ahead of the current_pose

          local_x = -1
          i = self.last_closest_front_waypoint_index - 1
          while ((i < self.base_waypoints_num-1) and (local_x <= 0)):
              i = (i + 1) # % self.base_waypoints_num
              # rospy.loginfo('index of i, searching for the nearest waypoint in front: %r' % i)
              waypoint = self.base_waypoints[i]
              w_pos = waypoint.pose.pose.position
              local_x, local_y = to_local_coordinates(current_pose.x, current_pose.y, yaw,
                                                      w_pos.x, w_pos.y)
          # end of while (local_x < 0)
          self.last_closest_front_waypoint_index = i
          # make the update last_closest_front_waypoint_index atomic with the search of the next one.
          return i
      # end of if self.base_waypoints_num is not None
      return None
#+END_SRC

** distance

The computation of the distance between two waypoints can be done by the distances of those
starting from the start to the i_th node, and j_th node.

This is an optimization in computation.

#+NAME:distance
#+BEGIN_SRC python :noweb tangle :tangle
  def distance(self, wp1, wp2):
      if (wp1 < wp2):
          start, end = wp1, wp2
      else:
          start, end = wp2, wp1
      # end of if (wp1 < wp2)

      dist = self.dist_to_here_from_start[end] - self.dist_to_here_from_start[start]
      return dist
#+END_SRC

** distance_two_indices

The distance function used to calculate the initial distance between two adjacent waypoints. It's needed before the distance from
base_waypoint start to the a base_waypoint is calculated.

#+NAME:distance_two_indices
#+BEGIN_SRC python :noweb tangle :tangle
  def distance_two_indices(self, waypoints, i, j):
    a = waypoints[i].pose.pose.position
    b = waypoints[j].pose.pose.position
    return math.sqrt((a.x-b.x)**2 + (a.y-b.y)**2  + (a.z-b.z)**2)
#+END_SRC

** to convert a global coordinates to local coordinates:
    It's based on the wiki:
    https://en.wikipedia.org/wiki/Rotation_matrix

    This implementation assumes the rotation has positive value from the global x-axis to the local x-axis
    counter-clockwise.

This following one works based on the experiment.

   #+NAME:to_local_coordinates
   #+BEGIN_SRC python :noweb tangle :tangle
     def to_local_coordinates(local_origin_x, local_origin_y, rotation, x, y):
         """
         compute the local coordinates for the global x, y coordinates values,
         given the local_origin_x, local_origin_y, and the rotation of the local x-axis.
         Assume the rotation is radius
         """
         shift_x = x - local_origin_x
         shift_y = y - local_origin_y

         cos_rotation = math.cos(rotation)
         sin_rotation = math.sin(rotation)

         local_x =  cos_rotation*shift_x + sin_rotation*shift_y
         local_y = -sin_rotation*shift_x + cos_rotation*shift_y  # according to John Chen's
         # assuming the orientation angle clockwise being positive
         return local_x, local_y
   #+END_SRC

Based on experiment, the following does not work.

#+NAME:to_local_coordinates_counter_clockwise_orientation
   #+BEGIN_SRC python :noweb tangle :tangle
  def to_local_coordinates(local_origin_x, local_origin_y, rotation, x, y):
      """
      compute the local coordinates for the global x, y coordinates values,
      given the local_origin_x, local_origin_y, and the rotation of the local x-axis.
      Assume the rotation is radius
      """
      shift_x = x - local_origin_x
      shift_y = y - local_origin_y

      cos_rotation = math.cos(rotation)
      sin_rotation = math.sin(rotation)

      local_x = cos_rotation*shift_x - sin_rotation*shift_y
      local_y = sin_rotation*shift_x + cos_rotation*shift_y  # according to John Chen's
      # assuming the orientation angle counter-clockwise being positive
      return local_x, local_y
   #+END_SRC


** How to calculate my_car's yaw angle, given its orientation in quaternion:

      The unit of the returned value is in radius?
      To check the documentation of transformations.euler_from_quaternion

#+NAME:get_yaw
#+BEGIN_SRC python :noweb tangle :tangle
  import tf as tf_ros                      # This is of ROS geometry, not of TensorFlow!
  def get_yaw(orientation):
      """
      Compute yaw from orientation, which is in Quaternion.
      """
      # orientation = msg.pose.orientation
      euler = tf_ros.transformations.euler_from_quaternion([
          orientation.x,
          orientation.y,
          orientation.z,
          orientation.w])
      yaw = euler[2]
      return yaw
#+END_SRC


* Scratch

          # update self.base_waypoints at self.traffic_waypoint to accelerate when there is no red light
          self.base_waypoints[self.traffic_waypoint-1].twist.twist.linear.x = (
              self.base_waypoints[self.traffic_waypoint-1].twist.twist.linear.x * 1.30)
          self.base_waypoints[self.traffic_waypoint].twist.twist.linear.x = (
              self.base_waypoints[self.traffic_waypoint].twist.twist.linear.x * 1.10)
* Obsoleted
** traffic_light_waypoint

   This is obsolete. It's been replaced by the computation of
   self.waypoint_to_light = waypoint_to_light_f(lights_to_waypoints, self.base_waypoints_num) in traffic_lights_to_waypoints

   A function from an index of a waypoint (ahead of the car) to the waypoint index of the traffic light.

   This should be the replacement for self.find_closest_traffic_light

#+NAME:traffic_light_waypoint_obsolete
#+BEGIN_SRC python :noweb tangle :tangle
  # construct a function or map from waypoint index in front of a car to the index of the waypoirt for traffic light
  # I know how to do it with map, but how to do it with function?

  def traffic_light_waypoint(self, waypoint_index):
      if self.waypoint_to_light is None:
          # construct the map
          self.waypoint_to_light = {}
          waypoint_start = 0
          for light_index in range(len(self.lights_to_waypoints)):
              for waypoint_index in range(waypoint_start, self.base_waypoints_num):
                  if waypoint_index < self.lights_to_waypoints[light_index]:
                      self.waypoint_to_light[waypoint_index] = self.lights_to_waypoints[light_index]
                  # end of if waypoint_index <= self.lights_to_waypoints[light_index]
                  waypoint_start = waypoint_index
              # end of for i in range(self.base_waypoints_num)
          # end of for light_index in range(len(self.lights_to_waypoints))
      # end of if self.waypoint_to_light is None
      return self.waypoint_to_light[waypoint_index]
#+END_SRC
