#+LATEX_CLASS: article
#+LATEX_CLASS_OPTIONS:
#+LATEX_HEADER:
#+LATEX_HEADER_EXTRA:
#+DESCRIPTION:
#+KEYWORDS:
#+SUBTITLE:
#+LATEX_COMPILER: pdflatex
#+DATE: \today

#+OPTIONS: ^:nil

* High level requirements

- The car should stop at the end of the base_waypoints, i.e. the end of the track. (So no looping around is needed.)


* Use Case: Waypoint Updater providing final_waypoints

** Work-flow

   To build Waypoint_Updater:

   #+NAME:
   #+BEGIN_SRC shell
     cd ros
     catkin_make
   #+END_SRC

In a separate shell:
#+NAME:
#+BEGIN_SRC shell
source devel/setup.sh
rostopic echo /final_waypoints
#+END_SRC
expect to see the published final_waypoints.

In a separate shell:
#+NAME:
#+BEGIN_SRC shell
source devel/setup.sh
roslaunch launch/styx.launch
#+END_SRC

In a separate shell, start the car simulator:

#+NAME:
#+BEGIN_SRC shell
#!/bin/bash
if [[ ! `pidof -s term3_sim.x86_64` ]]; then
    /home/yubrshen/ai-study/sdc/term3/linux_sys_int/system_integration.x86_64
fi
#+END_SRC

Note, one need to customize for the path for the simulator executable.

   Eventually, after the working of dbw_node, we should see the car's movement in the simulator.

** Experience sharing

   It's quite time consuming to fix bugs, as there are a lots of print-outs in the shell for Waypoint_Updater, one has to
scroll back to figure out what when wrong. Often, only one error would be reported, and one has to repeat the above work-flow for
every iterations.

If you know bettor work-flow or tools, please share.

** messages involved
*** Message types

**** geometry_msgs/PoseStamped

     #+BEGIN_EXAMPLE
     $ rosmsg info geometry_msgs/PoseStamped
     std_msgs/Header header
     uint32 seq
     time stamp
     string frame_id
     geometry_msgs/Pose pose
     geometry_msgs/Point position
     float64 x
     float64 y
     float64 z
     geometry_msgs/Quaternion orientation
     float64 x
     float64 y
     float64 z
     float64 w

     #+END_EXAMPLE
     Characterize the position and orientation of a waypoint, used in styx_msg/Lane for waypoints

     Example of access/manipulation in Python:

     See the example for styx_msgs/Lane.

**** styx_msgs/Lane
     List of waypoints, used to for /base_waypoints and /final_waypoints

     #+BEGIN_EXAMPLE
     std_msgs/Header header
     uint32 seq
     time stamp
     string frame_id
     styx_msgs/Waypoint[] waypoints
     geometry_msgs/PoseStamped pose
     std_msgs/Header header
     uint32 seq
     time stamp
     string frame_id
     geometry_msgs/Pose pose
     geometry_msgs/Point position
     float64 x
     float64 y
     float64 z
     geometry_msgs/Quaternion orientation
     float64 x
     float64 y
     float64 z
     float64 w
     geometry_msgs/TwistStamped twist
     std_msgs/Header header
     uint32 seq
     time stamp
     string frame_id
     geometry_msgs/Twist twist
     geometry_msgs/Vector3 linear
     float64 x
     float64 y
     float64 z
     geometry_msgs/Vector3 angular
     float64 x
     float64 y
     float64 z
     #+END_EXAMPLE

     Example of access/manipulation in Python:

     #+NAME:
     #+BEGIN_SRC python :noweb yes :tangle :exports none
       // my_lane_msg is of type styx_msgs/Lane
       // The geometry_msgs/PoseStamped component:
       my_lane_msg[0].pose
       // The x coordinate of the position of the waypoint:
       my_lane_msg[0].pose.position.x
       // The w orientation at the position of the waypoint:
       my_lane_msg[0].pose.orientation.w

       // for the x direction linear velocity:
       my_lane_msg[0].twist.twist.linear.x
     #+END_SRC

*** /base_waypoints : input

    All the waypoints on the track.
    Note, this is only published once, so it must be stored by the Waypoint_Updater.

*** /current_pose : input

    The current position of the car, with orientation.

*** /final_waypoints : output

    The positions to be for the car after the current position, with the specified speed in
    the fields of twist.

    We only need to set the speed for the linear.x dimension. It's based on the information: [[https://discussions.udacity.com/t/what-is-the-meaning-of-the-various-waypoint-fields/406030/2][waypoint field definitions]]

    The angular speed on z dimension might be needed for turning? Not quite sure about it.

** Design Sketch for producing final_wayponts

   1. Subscribe for /base_points to get all the available waypoints
      Note: need to store the base_points, as it's only published once.

   2. Subscribe for /current_pose to trigger the generation of the final_waypoints (waypoints forward) up to LOOKAHEAD_WPS

      Here is the algorithm to generate:
      - only select those that are ahead of the current_pose

      - determine the speed required for the selected waypoints

      - published the computed waypoint forward to /final_waypoints

   3. How to tell if a waypont is ahead of the my_car, given my_car's position.

   Convert the waypoint's global coordinates to my_car's coordinates, waypoint_local_x, waypoint_local_y,
   if 0 <= waypoint_local_x, and the angle between the local_x-axis (my_car's orientation)
   and the line from the local coordinate origin (my_car's current position) to the waypoint's coordinates is not too large,
   that is, it's not too much of side-way movement.
then the waypoint is front of my_car.

   Those eligible waypoints should be sorted increasing by waypoint_local_x value, for the same waypoint_local_x,
   only choose the one with the smallest waypont_local_y.

   I'm not clear whether it's OK to miss some waypoints along the path of my_car in the publishing the /final_points?
   For example, there are waypoints on the track ahead of my_car, A, B, C, is it OK to just publish A, and C?  For example, for some reason, by program consider B is not a valid waypoint ahead.

** Code construction

   This section provides the detailed design and construction of the code for Waypoint_Updater.
*** Waypoint_Uploader integration

    This is the full source code for ./ros/src/waypoint_updater/waypoint_updater.py

    - 11/6 ::
    change LOOKAHEAD_TIME_THRESHOLD from 5 to 4 seconds, as I found that in pure_pursuit,
    it only look ahead about 20 meters, with velocity of 10 mps, it will only take about 2 seconds.
    So 4 seconds should be enough.

    - 11/6 ::
    add queue_size=1 to both Subscriber to /current_pose and /base_waypoints. This is to limit to process the most recent message.
    Any message that Waypoint_Update has no time to update would be discarded.

    - 11/6 ::
    Change the logic of processing /current_pose from call_back to separate loop to ensure regular time interval processing.
  - 11/7 ::
  add self.last_closest_front_waypoint_index to record the index of last the closet waypoint in front of the vehicle.
  This would be the index to search next time, to save computing. (Beware of index wrapping in index increment arithmetic!)

  - 11/7 ::
  reduce LOOKAHEAD_WPS to 50 and do away from distance calculation to save computing effort. It seems that 50 is enough
  for normal driving.

  - 11/8 ::
  Need to consider to reduce the speed when there is significant turn.

  How to characterize the turn? I might use the local coordinate transformation.
  Relative to a waypoint A, From the next waypoint's coordinates, x, y in the local coordinate of A,
  one can compute the angle between A's x-axis, and the direction AB by atan2(y, x). The larger the angle,
  the sharper the turn at A would be, so the speed at the A should be reduced.

  I may just calculate just the first a few, say 5 from the closest waypoint in front to save computing effort.

  - 11/12 ::
  Add temporarily subscribe to /vehicle/traffic_lights, to simulate the detection of the traffic lights.

#+NAME:waypont_updater
#+BEGIN_SRC python :noweb tangle :tangle ./ros/src/waypoint_updater/waypoint_updater.py
  #!/usr/bin/env python
  <<imports>>

  '''
  This node will publish waypoints from the car's current position to some `x` distance ahead.

  As mentioned in the doc, you should ideally first implement a version which does not care
  about traffic lights or obstacles.

  Once you have created dbw_node, you will update this node to use the status of traffic lights too.

  Please note that our simulator also provides the exact location of traffic lights and their
  current status in `/vehicle/traffic_lights` message. You can use this message to build this node
  as well as to verify your TL classifier.

  TODO (for Yousuf and Aaron): Stopline location for each traffic light.
  '''
  LOOKAHEAD_WPS = 30 # 200 # Number of waypoints we will publish. You can change this number
  LOOKAHEAD_TIME_THRESHOLD = 4 # seconds, change from 5 to 4
  SAEF_TURNING_SPEED = 3.0       # meters/second

  DANGER_TURNING_ANGLE = math.pi/4  # 30 degree
  MPH_to_MPS = 1609.344/3600.0 # 1 mile = 1609.344 1 hour = 3600 seconds

  <<publish_Lane>>
  <<velocity-timing-constants>>

  class WaypointUpdater(WaypointTracker):
      def __init__(self):
          # f = open("~/.ros/log/stderr.log", "w+") # not working here
          # self.original_stderr = sys.stderr
          # sys.stderr = f
          # self.stopped = False
          rospy.init_node('waypoint_updater')
          self.max_vel_mps = rospy.get_param('waypoint_loader/velocity')*MPH_to_MPS
          rospy.loginfo('max_vel_mps: %f' % self.max_vel_mps)
          self.loop_freq = rospy.get_param('~loop_freq', 2)
          # the frequency to process vehicle messages

          WaypointTracker.__init__(self)

          self.current_pose_sub = rospy.Subscriber('/current_pose', PoseStamped, self.current_pose_cb)
          self.base_waypoints_sub = rospy.Subscriber('/base_waypoints', Lane, self.base_waypoints_cb)

          # TODO: Add a subscriber for /traffic_waypoint and /obstacle_waypoint below
          self.traffic_waypoint = None
          self.new_traffic_waypoint = False  # whether there is new traffic_waypoint data to process

          self.obstacle_waypoint = None
          self.current_velocity = None
          self.velocity_policy = None

          # self.traffic_lights = None
          rospy.Subscriber('/traffic_waypoint', Int32, self.traffic_waypoint_cb)
          # rospy.Subscriber('/vehicle/traffic_lights', TrafficLightArray, self.traffic_lights_cb)

          rospy.Subscriber('/current_velocity', TwistStamped, self.current_velocity_cb)
          rospy.Subscriber('/obstacle_waypoint', Int32, self.obstacle_cb)

          self.final_waypoints_pub = rospy.Publisher('final_waypoints', Lane, queue_size=1)

          # TODO: Add other member variables you need below

          # self.base_waypoints = None  # indicating the base_waypoints is not yet available
          # self.pose = None            # indicating that there is no message to process

          self.loop()
          #rospy.spin()

      <<constant-policy>>
      <<deceleration-policy>>
      <<cruise_unless_near_the_end>>
      <<loop>>
      <<base_waypoints_cb>>
      <<traffic_waypoint_cb>>
      <<current_velocity_cb>>
      <<obstacle_cb>>

      <<support_functions>>

  if __name__ == '__main__':
      try:
          WaypointUpdater()
      except rospy.ROSInterruptException:
          rospy.logerr('Could not start waypoint updater node.')

#+END_SRC

The following are the implementations.

*** imports

#+NAME:imports
#+BEGIN_SRC python :noweb tangle :tangle
  import sys                      # for redirect stderr
  import rospy

  import copy                     # for deepcopy
  import numpy as np              # for polyfit and poly1d

  import math

  from std_msgs.msg import Int32
  from geometry_msgs.msg import PoseStamped, TwistStamped
  from styx_msgs.msg import Lane, Waypoint
  from styx_msgs.msg import TrafficLightArray
  from waypoint_lib.waypoint_tracker import WaypointTracker
#+END_SRC

*** base_waypoints_cb

In the following code of modifying global variable may not be a good idea:

#+NAME:potential-improvement
#+BEGIN_SRC python :noweb tangle :tangle
global LOOKAHEAD_WPS        # might update it
LOOKAHEAD_WPS = min(LOOKAHEAD_WPS, self.base_waypoints_num)
#+END_SRC

It may be to compute a new member attribute of WaypointUpdater:

#+NAME:improvement-to-LOOKAHEAD_WPS
#+BEGIN_SRC python :noweb tangle :tangle
  self.lookahead = min(LOOKAHEAD_WPS, self.base_waypoints_num)
#+END_SRC
and to replace LOOKAHEAD_WPS in the body of WaypointUpdater by self.lookahead
but it may not matter as the modification is still constant through the life cycle of program.

#+NAME:base_waypoints_cb
#+BEGIN_SRC python :noweb tangle :tangle
  def base_waypoints_cb(self, msg):
      WaypointTracker.base_waypoints_process(self, msg)

      global LOOKAHEAD_WPS        # might update it
      LOOKAHEAD_WPS = min(LOOKAHEAD_WPS, self.base_waypoints_num)
      # construct the velocity policy
      self.cruise_policy = self.constant_policy_f(self.max_vel_mps, LOOKAHEAD_WPS)
      self.stop_policy = self.constant_policy_f(-0.01, LOOKAHEAD_WPS)
      self.deceleration_policy = self.decleration_policy_f(self.max_vel_mps,
                                                           LOOKAHEAD_WPS)

      # set the deceleration when approaching the end of the track
      total_length = self.dist_to_here_from_start[self.base_waypoints_num-1]
      # the total distance from the start to finish
      for i in range(LOOKAHEAD_WPS):
          last_ith = self.base_waypoints_num - 1 - LOOKAHEAD_WPS+i
          dist_to_the_end = (total_length - self.dist_to_here_from_start[last_ith])
          expected_velocity = self.deceleration_policy(dist_to_the_end)
          self.base_waypoints[last_ith].twist.twist.linear.x = expected_velocity
      # end of for i in range(LOOKAHEAD_WPS)
#+END_SRC

*** velocity-policy

    Velocity policies are functions that take input of the distance to a reference point,
    in this context of vehicle control, it's the point where the car should reach
    certain velocity, e.g. 0.0.

    The construction of such policies are in terms of the starting velocity, and the range of the input to the policies.

    For constant policy, the velocity would be the constant value across all input range.

#+NAME:constant-policy
#+BEGIN_SRC python :noweb tangle :tangle
  def constant_policy_f(self, velocity, bound):
      xs = [-bound,   0.,       bound]
      ys = [velocity, velocity, velocity]
      return np.poly1d(np.polyfit(np.array(xs), np.array(ys), 2))
#+END_SRC

For deceleration policy, at input value of 0, the velocity should be 0, and the positive boundary of
the input, the velocity should be the normal velocity as specified. The decrease should be smooth.

#+NAME:deceleration-policy
#+BEGIN_SRC python :noweb tangle :tangle
  def decleration_policy_f(self, ref_vel, bound):
      xs = []
      ys = []

      xs.append(-bound)
      ys.append(-0.1)

      xs.append(0.)
      ys.append(-0.2)

      # 5 meters away
      xs.append(5)
      ys.append(MPH_to_MPS*.5)

      # 10 meters away
      xs.append(10)
      ys.append(MPH_to_MPS*5)

      # 16 meters away
      xs.append(16)
      ys.append(MPH_to_MPS*5)

      # 2 seconds away or 24 meters away, whichever longer
      xs.append(max([ref_vel*2, 24]))
      ys.append(max([ref_vel*.2, MPH_to_MPS*5]))

      # 4 seconds away or 45 meters away, whichever longer
      xs.append(max([ref_vel*4, 45]))
      ys.append(max([ref_vel*.3, MPH_to_MPS*6]))

      # 6 seconds away or 65 meters away, whichever longer
      xs.append(max([ref_vel*6, 65]))
      ys.append(max([ref_vel*.5, MPH_to_MPS*10]))

      # 8 seconds away, normal speed
      xs.append(max([ref_vel*8, 85]))
      ys.append(ref_vel)

      # at the beginning, normal speed
      xs.append(bound)
      ys.append(ref_vel)

      return np.poly1d(np.polyfit(np.array(xs), np.array(ys), 3))
#+END_SRC

*** traffic_waypoint_cb

    Store the published /traffic_waypoint data. It's expected to be utilized in the
    main loop of the traffic waypoint data.

#+NAME:traffic_waypoint_cb
#+BEGIN_SRC python :noweb tangle :tangle
  def traffic_waypoint_cb(self, msg):
      if self.traffic_waypoint != msg.data:
          self.new_traffic_waypoint = True
          self.traffic_waypoint = msg.data
          if msg.data < 0:
              self.traffic_light_red = False
              self.traffic_waypoint = -msg.data
          else:
              self.traffic_light_red = True
              self.traffic_waypoint = msg.data
          # end of if msg.data < 0
      else:
          self.new_traffic_waypoint = False
      # end of if self.traffic_waypoint != msg.data

#+END_SRC

*** adjust_velocity_for_traffic_light

In the context of loop for processing the /pose message, determine the velocity policy,
and adjust the velocity for each final_waypoints

By the current logic, tl_detector will only publish /traffic_waypoint if there is a red traffic light detected.

There might be another case that the car should slow down,
where it's close to next traffic light, regardless of the traffic light's color.
To implement this, we need to have the capability to know distance to the next traffic light.
It seems to me that this might be an abstraction
should be done in WaypointTracker.

MAJOR CHANGE of the protocol between waypoints_updater and tl_detector ::
when the traffic light color is not red, report the negative of the waypoint index instead of just report -1, to take advantage of the computation of the waypoint index of the traffic light, saving waypoint_updater from computing it.

#+NAME:adjust_velocity_for_traffic_light
#+BEGIN_SRC python :noweb tangle :tangle
  # policy for velocity adjustment in view of traffic light
  if (self.current_velocity and (0 < self.current_velocity) and
      # self.new_traffic_waypoint and
      self.traffic_waypoint and (self.last_closest_front_waypoint_index < self.traffic_waypoint)):
      distance_to_traffic_light = self.distance(
          self.last_closest_front_waypoint_index, self.traffic_waypoint)
      time_to_traffic_light = distance_to_traffic_light/self.current_velocity

      <<determine-velocity-policy>>

      if self.traffic_light_red:
          rospy.loginfo(
              'current_waypoint: %d; traffic_waypoint: %d; light: RED: %r; Distance to light: %r; Time to light: %d; velocity policy: %s' %
              (self.last_closest_front_waypoint_index, self.traffic_waypoint, self.traffic_light_red, distance_to_traffic_light,
               time_to_traffic_light, self.policy_name()))
      # if self.traffic_light_red

      # apply the policy to each final_waypoints
      if self.velocity_policy:
          # for all final waypoints
          num_affected_waypoints = min(final_waypoints_count, self.traffic_waypoint - self.last_closest_front_waypoint_index)
          for i in range(num_affected_waypoints):
              j = self.last_closest_front_waypoint_index + i
              waypoint = final_waypoints[i]
              distance_to_traffic_light = self.distance(j, self.traffic_waypoint)
              waypoint.twist.twist.linear.x = self.velocity_policy(distance_to_traffic_light)
              rospy.loginfo('velocity policy: %s; index away from current pose: %d; linear.x: %f' %
                            (self.policy_name(), i, waypoint.twist.twist.linear.x))
          # end of for i in range(num_affected_waypoints)
      else:
          # for i in range(final_waypoints_count):
          #     rospy.loginfo('velocity policy: %s; index away from current pose: %d; linear.x: %f' %
          #                   (self.policy_name(), i, final_waypoints[i].twist.twist.linear.x))
          # end of for i in range(final_waypoints_count)
          pass                    # in place of the above commented out code
      # end of if self.velocity_policy
  # end of if self.current_velocity and 0 < self.current_velocity and self.traffic_waypoint
#+END_SRC

** determine-velocity-policy
#+NAME:velocity-timing-constants
#+BEGIN_SRC python :noweb tangle :tangle
  # TIME_TO_CRUISE = 20             # seconds, can keep the normal cruise speed
  TIME_TO_SLOWDOWN = 0.3  # seconds, must slowdown in anticipation, regardless of the color of the light
  TIME_TO_STOP_IF_RED = 0.1        # seconds, must stop if the traffic light is red
#+END_SRC

#+NAME:determine-velocity-policy
#+BEGIN_SRC python :noweb tangle :tangle
  if self.traffic_light_red:
      if self.velocity_policy == self.stop_policy:
          pass
      elif ((time_to_traffic_light < TIME_TO_STOP_IF_RED) or distance_to_traffic_light < 5):
          self.velocity_policy = self.stop_policy
      elif (time_to_traffic_light < TIME_TO_SLOWDOWN) or distance_to_traffic_light < 20:
          self.velocity_policy = self.decleration_policy_f(self.current_velocity, distance_to_traffic_light)
      # else: keep the original velocity
      # end of if self.velocity_policy == self.stop_policy
  # elif 20 < distance_to_traffic_light and distance_to_traffic_light < 70:
  #     self.velocity_policy = self.decleration_policy_f(self.current_velocity, distance_to_traffic_light)
  else:
      self.velocity_policy = None  # might want to implement some acceleration here
  # end of if self.traffic_light_red
#+END_SRC

Need to make sure the policy be reset to NONE when the light is no longer red.

#+NAME:determine-velocity-policy-old
#+BEGIN_SRC python :noweb tangle :tangle
    if self.traffic_light_red and ((time_to_traffic_light < TIME_TO_STOP_IF_RED) or distance_to_traffic_light < 5):
        velocity_policy = self.stop_policy
    elif self.traffic_light_red and (time_to_traffic_light < TIME_TO_SLOWDOWN):
        velocity_policy = self.decleration_policy_f(self.current_velocity, distance_to_traffic_light)
    elif (time_to_traffic_light < TIME_TO_CRUISE):
        velocity_policy = self.decleration_policy_f(self.current_velocity, distance_to_traffic_light)
    # end of if self.traffic_light_red and ((time_to_traffic_light < TIME_TO_STOP_IF_RED) or distance_to_traffic_light < 5)


#+END_SRC


*** cruise_unless_near_the_end

Use cruise policy, unless it's close to the end of the track (base_waypoints). When approaching the end,
the velocitise have been calculated, thus no need to have the policy to calculate.

#+NAME:cruise_unless_near_the_end
#+BEGIN_SRC python :noweb tangle :tangle
  def cruise_unless_near_the_end(self):
      if (self.base_waypoints_num - self.last_closest_front_waypoint_index) < LOOKAHEAD_WPS:
          velocity_policy = None
      else:
          velocity_policy = self.cruise_policy
      # end of if (self.base_waypoints_num - self.last_closest_front_waypoint_index) < LOOKAHEAD_WPS

      return velocity_policy
#+END_SRC

*** traffic_lights_cb

#+NAME:traffic_lights_cb
#+BEGIN_SRC python :noweb tangle :tangle
  def traffic_lights_cb(self, msg):
      self.traffic_lights = msg.lights
#+END_SRC

*** current_velocity_cb

#+NAME:current_velocity_cb
#+BEGIN_SRC python :noweb tangle :tangle
  def current_velocity_cb(self, msg):
      self.current_velocity = msg.twist.linear.x
#+END_SRC

*** obstacle_cb

#+NAME:obstacle_cb
#+BEGIN_SRC python :noweb tangle :tangle
  def obstacle_cb(self, msg):
      self.obstacle_waypoint = msg.data
#+END_SRC

*** loop

    The loop for processing the /current_pose message

    The design that the waypoints provided by the Waypoint_Uploader is consecutive, maintaining the geometry adjacency.

    Note, the generation for /final_waypoints may be conditional to the availability of the base_waypoints.

    The function may need other routine to compare between waypoints to determine if a waypoint is ahead of the current_pose within the LOOKAHEAD_WPS

    also compute the desired velocity for the eligible waypoints.

    try to control the time of looking ahead instead of just control the number of look ahead waypoints.
    to be adaptive so that it does not waste computing resource to produce too many waypoints.

    On Nov. 3, I experimented that the waypoints ahead generation can be simplified as follows
    without any negative impact:
    - no more angle checking
    - no more sorted needed


#+NAME:loop
#+BEGIN_SRC python :noweb tangle :tangle
  def loop(self):
      rate = rospy.Rate(self.loop_freq)
      while not rospy.is_shutdown():
          if self.base_waypoints and self.pose:
              <<process-pose>>
              self.pose = None        # indicating this message has been processed
          # end of if self.base_waypoints and self.pose
          rate.sleep()
      # end of while not rospy.is_shutdow()
#+END_SRC

*** process-pose

Process one pose message in self.pose

First find the next closest waypoint in front of the vehicle.
Then use that to generate the rest of the final_waypoints.

#+NAME:process-pose
#+BEGIN_SRC python :noweb tangle :tangle
  self.last_closest_front_waypoint_index = self.get_closest_waypoint(self.pose.pose)
  if self.last_closest_front_waypoint_index:
      # generate final_waypoints
      final_waypoints_count = 0
      lookahead_dist = 0  # the accumulated distance of the looking ahead
      lookahead_time = 0  # the lookahead time

      final_waypoints = []
      accumulated_turning = 0
      # dist_to_here_from_current = []

      # modulize the code to be less dependent
      j = self.last_closest_front_waypoint_index
      while (# (lookahead_time < LOOKAHEAD_TIME_THRESHOLD) and
              (final_waypoints_count < LOOKAHEAD_WPS) and
              (j < self.base_waypoints_num)):
          waypoint = copy.deepcopy(self.base_waypoints[j])
          j = (j + 1) # % self.base_waypoints_num
          final_waypoints_count += 1
          final_waypoints.append(waypoint)
      # end of while (LOOKAHEAD_TIME_THRESHOLD <= lookahead_time) or (LOOKAHEAD_WPS <= final_waypoints_count)

      # rospy.loginfo('Lookahead threshold reached: final_waypoints_count: %d; lookahead_time: %d; self.last_closest_front_waypoint_index: %d'
      #               % (final_waypoints_count, lookahead_time, self.last_closest_front_waypoint_index))

      <<adjust_velocity_for_traffic_light>>

      # publish to /final_waypoints, need to package final_waypoints into Lane message
      publish_Lane(self.final_waypoints_pub, final_waypoints)
  # end of if self.last_closest_front_waypoint_index
#+END_SRC

*** compare two pose, a and b, if a is ahead of b, considering the parameter of LOOKAHEAD_WPS

    Compare between two pose if one is ahead of the other within the range of LOOKAHEAD_WPS

    This problem is solved by converting the waypoint to the local coordinates of my_car.

*** select waypoints for /final_waypoints

    A loop or list expression to generate the list of eligible waypoints for /final_waypoints.
    It's implemented in the pose_cb.

*** determine the velocity for waypoints

    Compute the desired velocity for waypoints: for now, it's stab as constant. This is to be done (TBD).

*** Discussion on the appropriate value of LOOKAHEAD_WPS

    The value of LOOKAHEAD_WPS might impact the system work load. It should be sufficient large. But not too large.

* Use case: Stop at the red traffic light or at the end
** Design Considerations for Traffic Light Treatment

 - The time away from the traffic light ::
 It's the distance away from the traffic light divided by the current velocity of the car.

 This concept determines the velocity policy:

 The intuition: the closer, the car should be the slower, when it's approaching, the car should have 0 velocity.

 Let's start with the following threshold to experiment:

 Three threshold:

 Ignore: above 5 seconds

 Slow Down: within 3 seconds

 Must stop: within 2 seconds

 Based on the above consideration, here is the implementation:

 1. In the call back for traffic_waypoint, compute the time away from the traffic light
 2. Based the time away, implement the above policy
 3. To have the current velocity, need to subscribe and store the current velocity.

**** Simulation of Detection of Traffic Lights

     In the simulator, use of traffic lights data from the simulator, to
     tell whether there is a traffic light in red in front of the car in near distance.


***** message type: styx_msgs/TrafficLightArray

   #+BEGIN_EXAMPLE
     styx_msgs/TrafficLightArray
     std_msgs/Header header
       uint32 seq
       time stamp
       string frame_id
     styx_msgs/TrafficLight[] lights
       uint8 UNKNOWN=4
       uint8 GREEN=2
       uint8 YELLOW=1
       uint8 RED=0
       std_msgs/Header header
         uint32 seq
         time stamp
         string frame_id
       geometry_msgs/PoseStamped pose
         std_msgs/Header header
           uint32 seq
           time stamp
           string frame_id
         geometry_msgs/Pose pose
           geometry_msgs/Point position
             float64 x
             float64 y
             float64 z
           geometry_msgs/Quaternion orientation
             float64 x
             float64 y
             float64 z
             float64 w
       uint8 state

   #+END_EXAMPLE

* Support functions

#+NAME:publish_Lane
#+BEGIN_SRC python :noweb tangle :tangle
def publish_Lane(publisher, waypoints):
        lane = Lane()
        lane.header.frame_id = '/world'
        lane.header.stamp = rospy.Time(0)
        lane.waypoints = waypoints
        publisher.publish(lane)
#+END_SRC

#+NAME:support_functions
#+BEGIN_SRC python :noweb tangle :tangle
  def get_waypoint_velocity(self, waypoint):
          return waypoint.twist.twist.linear.x

  def set_waypoint_velocity(self, waypoints, waypoint, velocity):
          waypoints[waypoint].twist.twist.linear.x = velocity

  def policy_name(self):
      if self.velocity_policy == self.stop_policy:
          return "stop"
      elif self.velocity_policy is None:
          return "None"
      else:
          return "deceleration"   # by result of exclusion

#+END_SRC

* Message Sequence Charts

#+BEGIN_SRC plantuml :file traffic_light_report.png
tl_detector ->> waypoint_updater: /traffic_waypoint
#+END_SRC
#results:

#+BEGIN_SRC plantuml :file uml.png
styx_server ->> tl_dectector: /vehicle/traffic_lights
styx_server ->> waypoint_updater: /vehicle/traffic_lights
note over waypoint_updater: Just for simulation purpose
#+END_SRC
#results:


* Sketch of Waypoint_Updater:loop

#+BEGIN_SRC plantuml :file waypoint-updater-loop.png
@startuml
start
while (not shutdown) is (running)
:determine the position of the car in terms of waypoint:
find the closest waypoint in front of the car
based on /pose message recevied;
:generate final_waypoints based on base_waypoints:
(the waypoints ahead of the car);
:adjust velocity for the final_waypoints:
(in terms of the time to reach the next traffic light,
based on
the distance to the next traffic light
(by /traffic_waypoint received),
the car's velocity) and the color of the next light;
:publish /final_waypoints;
endwhile (stop)
stop
@enduml
#+END_SRC

#+RESULTS:
[[file:waypoint-updater-loop.png]]

#results:
